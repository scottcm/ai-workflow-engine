"""Integration tests for multi-provider workflow scenarios.

Tests scenarios where different providers are used for different roles,
verifying correct provider invocation and error handling across phases.
"""

from pathlib import Path
from typing import Any

import pytest

# Import profiles to trigger registration
import profiles  # noqa: F401

from aiwf.application.workflow_orchestrator import WorkflowOrchestrator
from aiwf.domain.errors import ProviderError
from aiwf.domain.models.workflow_state import (
    ExecutionMode,
    WorkflowPhase,
    WorkflowStatus,
)
from aiwf.domain.persistence.session_store import SessionStore
from aiwf.domain.providers.ai_provider import AIProvider
from aiwf.domain.providers.provider_factory import ProviderFactory


@pytest.fixture
def jpa_mt_env(tmp_path, monkeypatch):
    """Set up JPA-MT profile environment."""
    standards_dir = tmp_path / "standards"
    standards_dir.mkdir(exist_ok=True)
    monkeypatch.setenv("STANDARDS_DIR", str(standards_dir))

    # Create required stub standards files
    required_files = [
        "ORG.md",
        "NAMING_AND_API.md",
        "PACKAGES_AND_LAYERS.md",
        "JPA_AND_DATABASE.md",
        "ARCHITECTURE_AND_MULTITENANCY.md",
        "BOILERPLATE_AND_DI.md",
    ]
    for filename in required_files:
        (standards_dir / filename).write_text(f"# {filename}\n\nStub content.\n")

    # Create schema file for jpa-mt profile
    schema_file = tmp_path / "schema.sql"
    schema_file.write_text(
        "CREATE TABLE app.test_entity (id BIGINT PRIMARY KEY);", encoding="utf-8"
    )

    # Change cwd to tmp_path so schema file can be found
    monkeypatch.chdir(tmp_path)

    return tmp_path


class PlannerProvider(AIProvider):
    """Provider for planning phase."""

    call_count: int = 0

    def __init__(self, config: dict[str, Any] | None = None):
        self.config = config or {}

    @classmethod
    def get_metadata(cls) -> dict[str, Any]:
        return {
            "name": "planner-provider",
            "description": "Provider for planning",
            "requires_config": False,
            "config_keys": [],
            "default_connection_timeout": 10,
            "default_response_timeout": 60,
        }

    def validate(self) -> None:
        pass

    def generate(
        self,
        prompt: str,
        context: dict[str, Any] | None = None,
        connection_timeout: int | None = None,
        response_timeout: int | None = None,
    ) -> str | None:
        PlannerProvider.call_count += 1
        return "# Planning Response\n\nPlan created by planner-provider."


class GeneratorProvider(AIProvider):
    """Provider for generation phase."""

    call_count: int = 0

    def __init__(self, config: dict[str, Any] | None = None):
        self.config = config or {}

    @classmethod
    def get_metadata(cls) -> dict[str, Any]:
        return {
            "name": "generator-provider",
            "description": "Provider for generation",
            "requires_config": False,
            "config_keys": [],
            "default_connection_timeout": 10,
            "default_response_timeout": 120,
        }

    def validate(self) -> None:
        pass

    def generate(
        self,
        prompt: str,
        context: dict[str, Any] | None = None,
        connection_timeout: int | None = None,
        response_timeout: int | None = None,
    ) -> str | None:
        GeneratorProvider.call_count += 1
        return "# Generation Response\n\nCode generated by generator-provider."


class FailingPlannerProvider(AIProvider):
    """Provider that fails during planning."""

    def __init__(self, config: dict[str, Any] | None = None):
        self.config = config or {}

    @classmethod
    def get_metadata(cls) -> dict[str, Any]:
        return {
            "name": "failing-planner",
            "description": "Failing planner provider",
            "requires_config": False,
            "config_keys": [],
            "default_connection_timeout": 10,
            "default_response_timeout": 60,
        }

    def validate(self) -> None:
        pass

    def generate(
        self,
        prompt: str,
        context: dict[str, Any] | None = None,
        connection_timeout: int | None = None,
        response_timeout: int | None = None,
    ) -> str | None:
        raise ProviderError("Planner provider unavailable")


class FailingGeneratorProvider(AIProvider):
    """Provider that fails during generation."""

    def __init__(self, config: dict[str, Any] | None = None):
        self.config = config or {}

    @classmethod
    def get_metadata(cls) -> dict[str, Any]:
        return {
            "name": "failing-generator",
            "description": "Failing generator provider",
            "requires_config": False,
            "config_keys": [],
            "default_connection_timeout": 10,
            "default_response_timeout": 120,
        }

    def validate(self) -> None:
        pass

    def generate(
        self,
        prompt: str,
        context: dict[str, Any] | None = None,
        connection_timeout: int | None = None,
        response_timeout: int | None = None,
    ) -> str | None:
        raise ProviderError("Generator provider unavailable")


@pytest.fixture
def register_multi_providers():
    """Register test providers and clean up after."""
    original_registry = dict(ProviderFactory._registry)
    ProviderFactory.register("planner-provider", PlannerProvider)
    ProviderFactory.register("generator-provider", GeneratorProvider)
    ProviderFactory.register("failing-planner", FailingPlannerProvider)
    ProviderFactory.register("failing-generator", FailingGeneratorProvider)

    # Reset call counts
    PlannerProvider.call_count = 0
    GeneratorProvider.call_count = 0

    yield

    ProviderFactory._registry.clear()
    ProviderFactory._registry.update(original_registry)


class TestMultiProviderWorkflow:
    """Tests for workflows using different providers per role."""

    def test_different_providers_per_role(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Different providers can be assigned to different roles."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "planner-provider",
                "generator": "generator-provider",
                "reviewer": "manual",
                "reviser": "manual",
            },
        )

        # Verify providers are stored correctly
        state = store.load(session_id)
        assert state.providers["planner"] == "planner-provider"
        assert state.providers["generator"] == "generator-provider"
        assert state.providers["reviewer"] == "manual"
        assert state.providers["reviser"] == "manual"

    def test_planner_provider_invoked_in_planning_phase(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Planner provider is invoked during PLANNING phase approval."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        PlannerProvider.call_count = 0

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "planner-provider",
                "generator": "generator-provider",
            },
        )

        # Step to PLANNING
        orchestrator.step(session_id)

        # Approve - should invoke planner provider
        orchestrator.approve(session_id)

        assert PlannerProvider.call_count == 1
        assert GeneratorProvider.call_count == 0  # Not invoked yet

    def test_generator_provider_invoked_in_generating_phase(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Generator provider is invoked during GENERATING phase approval."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "planner-provider",
                "generator": "generator-provider",
            },
        )

        # Go through PLANNING
        orchestrator.step(session_id)
        orchestrator.approve(session_id)  # Creates planning response
        orchestrator.step(session_id)  # Advances to PLANNED
        orchestrator.approve(session_id)  # Approves plan

        # Step to GENERATING
        result = orchestrator.step(session_id)
        assert result.phase == WorkflowPhase.GENERATING

        # Reset counts before generator approval
        PlannerProvider.call_count = 0
        GeneratorProvider.call_count = 0

        # Approve - should invoke generator provider
        orchestrator.approve(session_id)

        assert GeneratorProvider.call_count == 1
        assert PlannerProvider.call_count == 0  # Should not be invoked

    def test_provider_failure_in_one_role_does_not_affect_others(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Failure in planner role leaves generator role unaffected."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "failing-planner",
                "generator": "generator-provider",
            },
        )

        # Step to PLANNING
        orchestrator.step(session_id)

        # Approve should fail
        result = orchestrator.approve(session_id)
        assert result.status == WorkflowStatus.ERROR
        assert "Planner provider unavailable" in result.last_error

        # Generator was never invoked
        assert GeneratorProvider.call_count == 0

    def test_mixed_manual_auto_workflow(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Workflow with mix of manual and auto providers works correctly."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "manual",  # Manual for planning
                "generator": "generator-provider",  # Auto for generation
            },
        )

        # Step to PLANNING
        orchestrator.step(session_id)

        # Manual approve - no response written
        orchestrator.approve(session_id)

        # Verify still in PLANNING (waiting for manual response)
        state = store.load(session_id)
        assert state.phase == WorkflowPhase.PLANNING

        # User provides manual planning response
        response_file = (
            sessions_root / session_id / "iteration-1" / "planning-response.md"
        )
        response_file.write_text(
            "# Planning Response\n\nManual plan.",
            encoding="utf-8",
        )

        # Step to PLANNED
        result = orchestrator.step(session_id)
        assert result.phase == WorkflowPhase.PLANNED

        # Approve plan
        orchestrator.approve(session_id)

        # Step to GENERATING
        result = orchestrator.step(session_id)
        assert result.phase == WorkflowPhase.GENERATING

        # Approve with auto provider
        GeneratorProvider.call_count = 0
        orchestrator.approve(session_id)

        # Auto provider should have been invoked
        assert GeneratorProvider.call_count == 1

    def test_generator_failure_after_planner_success(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Generator failure after successful planning leaves workflow in ERROR state.

        This test verifies that when a later-phase provider (generator) fails
        after an earlier phase (planning) has succeeded:
        1. The workflow status is set to ERROR
        2. The phase does NOT advance past GENERATING
        3. The error message is captured in last_error
        4. The planner's successful work is preserved
        """
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "planner-provider",  # Will succeed
                "generator": "failing-generator",  # Will fail
            },
        )

        # Complete PLANNING phase successfully
        orchestrator.step(session_id)  # INITIALIZED -> PLANNING
        orchestrator.approve(session_id)  # Planner succeeds, writes response
        assert PlannerProvider.call_count == 1

        # Verify planning response was written
        planning_response = (
            sessions_root / session_id / "iteration-1" / "planning-response.md"
        )
        assert planning_response.exists()

        # Move through PLANNED
        orchestrator.step(session_id)  # PLANNING -> PLANNED
        state = store.load(session_id)
        assert state.phase == WorkflowPhase.PLANNED

        orchestrator.approve(session_id)  # Approve the plan

        # Step to GENERATING
        result = orchestrator.step(session_id)
        assert result.phase == WorkflowPhase.GENERATING

        # Now approve with failing generator
        result = orchestrator.approve(session_id)

        # Verify ERROR state
        assert result.status == WorkflowStatus.ERROR
        assert "Generator provider unavailable" in result.last_error

        # Verify phase did NOT advance past GENERATING
        state = store.load(session_id)
        assert state.phase == WorkflowPhase.GENERATING
        assert state.status == WorkflowStatus.ERROR

        # Verify planning response is still preserved
        assert planning_response.exists()


class TestProviderRoleIsolation:
    """Tests for provider role isolation."""

    def test_each_phase_uses_correct_provider_role(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Each phase uses its designated provider role."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "planner-provider",
                "generator": "generator-provider",
                "reviewer": "manual",
                "reviser": "manual",
            },
        )

        # Track provider invocations
        PlannerProvider.call_count = 0
        GeneratorProvider.call_count = 0

        # PLANNING phase
        orchestrator.step(session_id)
        orchestrator.approve(session_id)
        assert PlannerProvider.call_count == 1
        assert GeneratorProvider.call_count == 0

        # PLANNED -> approve
        orchestrator.step(session_id)
        orchestrator.approve(session_id)

        # GENERATING phase
        orchestrator.step(session_id)
        orchestrator.approve(session_id)
        assert PlannerProvider.call_count == 1  # Not incremented
        assert GeneratorProvider.call_count == 1

    def test_provider_role_stored_in_session_state(
        self, jpa_mt_env: Path, register_multi_providers
    ):
        """Provider roles are persisted in session state."""
        sessions_root = jpa_mt_env
        store = SessionStore(sessions_root=sessions_root)
        orchestrator = WorkflowOrchestrator(
            session_store=store, sessions_root=sessions_root
        )

        session_id = orchestrator.initialize_run(
            profile="jpa-mt",
            context={
                "scope": "domain",
                "entity": "TestEntity",
                "table": "app.test_entity",
                "bounded_context": "test",
                "schema_file": "schema.sql",
            },
            providers={
                "planner": "planner-provider",
                "generator": "generator-provider",
                "reviewer": "manual",
                "reviser": "manual",
            },
        )

        # Reload from store
        state = store.load(session_id)

        assert state.providers == {
            "planner": "planner-provider",
            "generator": "generator-provider",
            "reviewer": "manual",
            "reviser": "manual",
        }