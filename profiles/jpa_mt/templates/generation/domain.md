{{include: _shared/base.md}}
{{include: _shared/fallback-rules.md}}
{{include: _phases/generation-guidelines.md}}

---

# Domain Layer Code Generation Request

_Version: 1.0_  
_Last updated: 2024-12-09_

This template generates production-quality Java code for a **domain layer** (Entity + Repository) based on an approved planning document.

---

## Context for This Request

You are in **Phase 2: Code Generation**.

**Phase 1 (Planning) is complete.** The developer has:
1. Reviewed the planning document
2. Approved the design
3. Answered any questions you raised

Your task now is to **generate the code exactly as planned**.

---

## Required Files

### Planning Document (required)

**File:** `planning-response.md`

This contains the approved design for the entity and repository. You MUST follow this design exactly:
- Entity name, package, and base class
- All fields with types and annotations
- All relationships with join columns and fetch strategies
- Repository name, package, and base interface
- All query methods with signatures

### Standards Bundle (required)

**File:** `standards-bundle.md`

Apply these standards to ensure code quality:
- Formatting rules (indentation, imports, etc.)
- Annotation requirements
- Naming conventions
- JavaDoc requirements (if any)

### Schema DDL (reference)

The schema DDL file is available for reference if needed, but the planning document is authoritative for what to generate.

**VALIDATION:**
If `planning-response.md` is missing: `VALIDATION FAILED: missing planning-response.md. Cannot generate code without approved plan.`

---

## Generation Instructions

### Step 1: Load and Parse Planning Document

Extract from the planning document:
1. **Entity Design:**
   - Class name
   - Package location
   - Base class (if any) and inherited fields
   - Fields to declare (with types, annotations, constraints)
   - Relationships (type, field name, join column, fetch strategy)

2. **Repository Design:**
   - Interface name
   - Package location
   - Base interface
   - Query methods (names, parameters, return types)

### Step 2: Apply Standards

From the standards bundle, apply:
- Package structure rules
- Import organization
- Annotation patterns
- Code formatting (indentation, spacing)
- JavaDoc requirements
- equals/hashCode/toString patterns (if specified)

### Step 3: Generate Entity Class

**Structure:**
```java
package [from plan];

[imports - organized per standards]

/**
 * [Entity description from plan or standards template]
 */
@Entity
@Table(name = "[table_name]", schema = "[schema_name]")
public class [EntityName] extends [BaseClass] {

    [Field declarations with annotations]
    
    [Relationship declarations with annotations]
    
    [Constructors - per standards]
    
    [Getters/Setters - per standards]
    
    [equals/hashCode/toString - per standards]
}
```

**Key Requirements:**
- ✅ All fields from plan
- ✅ Correct JPA annotations (@Column, @ManyToOne, @JoinColumn, etc.)
- ✅ No redeclaration of base class fields
- ✅ Proper Java types (OffsetDateTime for TIMESTAMPTZ, etc.)
- ✅ Fetch strategies from plan (LAZY/EAGER)
- ✅ Validation annotations if mentioned in plan

### Step 4: Generate Repository Interface

**Structure:**
```java
package [from plan];

[imports]

/**
 * [Repository description]
 */
public interface [EntityName]Repository extends [BaseInterface]<[EntityName], Long> {

    [Query methods from plan]
}
```

**Query Method Format:**
```java
// Spring Data method name
Optional<Entity> findByCode(String code);

// Or with @Query if complex
@Query("SELECT e FROM Entity e WHERE ...")
List<Entity> customQuery(Long param);
```

**Key Requirements:**
- ✅ All methods from plan
- ✅ Correct method names (Spring Data conventions OR @Query)
- ✅ Proper parameter types and names
- ✅ Proper return types (Optional<T>, List<T>, etc.)
- ✅ Tenant parameter included for tenant-scoped entities

---

## Output Format

### File: `generation-response.md`

**Document Header:**
```yaml
---
Generated by: [Your AI model name and version]
Generated at: [UTC timestamp, ISO 8601 format]
---
```

**Code Bundle:**
```
<<<FILE: [package-path]/[EntityName].java>>>
    package [package.name];
    
    [complete entity class, 4-space indented]

<<<FILE: [package-path]/[EntityName]Repository.java>>>
    package [package.name];
    
    [complete repository interface, 4-space indented]
```

**Example:**
```
<<<FILE: com/skillsharbor/backend/controlplane/domain/catalog/Tier.java>>>
    package com.skillsharbor.backend.controlplane.domain.catalog;
    
    import jakarta.persistence.*;
    import java.util.UUID;
    
    @Entity
    @Table(name = "tiers", schema = "global")
    public class Tier extends BaseEntity {
        
        @Column(name = "code", length = 50, unique = true, nullable = false)
        private String code;
        
        // ... rest of class
    }

<<<FILE: com/skillsharbor/backend/controlplane/domain/catalog/TierRepository.java>>>
    package com.skillsharbor.backend.controlplane.domain.catalog;
    
    import org.springframework.data.jpa.repository.JpaRepository;
    import java.util.Optional;
    import java.util.UUID;
    
    public interface TierRepository extends JpaRepository<Tier, Long> {
        
        Optional<Tier> findByCode(String code);
        
        Optional<Tier> findByPublicId(UUID publicId);
        
        // ... rest of methods
    }
```

---

## Pre-Output Validation

Before generating the code bundle, verify:

1. ✅ Planning document loaded and parsed
2. ✅ Standards bundle loaded and understood
3. ✅ Entity class name, package, base class determined
4. ✅ All entity fields extracted from plan
5. ✅ All relationships extracted from plan
6. ✅ Repository interface name, package, base interface determined
7. ✅ All query methods extracted from plan
8. ✅ All JPA annotations known and correct
9. ✅ Code follows standards formatting rules
10. ✅ No deviations from approved plan

If validation fails: `VALIDATION FAILED: [issue]. Cannot proceed because: [explanation].`

---

## Important Reminders

### From Planning Document

The planning document is your **blueprint**. Do NOT:
- Add fields not in the plan
- Change field types from the plan
- Add or remove relationships from the plan
- Add methods not in the plan
- Change entity or repository names from the plan

### From Standards Bundle

The standards bundle defines **how to write the code**. Do:
- Follow package structure rules
- Use specified annotation patterns
- Apply formatting conventions
- Include required JavaDoc (if specified)
- Follow naming patterns

### Code Quality

Generate **production-ready code**:
- Compiles without errors
- No placeholders or TODOs
- Complete imports
- Proper indentation (4 spaces)
- Clean, readable code

---

## Critical Rules

1. **Follow the plan exactly** — No creativity, no improvements, no additions
2. **Apply standards rigorously** — Code must match conventions
3. **Generate complete code** — No partial implementations
4. **Use correct bundle format** — Engine needs to parse this
5. **Include proper paths** — Package structure must be correct

---

## What Happens Next

After you generate the code:
1. Developer extracts files from bundle
2. Code is compiled and tested
3. **Phase 3: Code Review** — Another AI reviews the code
4. If review fails → **Phase 4: Revision** → regenerate with fixes

Your code WILL be reviewed, so quality matters!

---