# JPA-MT Planning Prompt Configuration
# This file defines the structure of planning prompts for all scopes.
# The profile assembles the final prompt by selecting sections based on scope/artifacts.

# =============================================================================
# ROLE
# =============================================================================
role:
  title: JPA Multi-Tenant Entity Planning
  description: |
    You are a senior Java architect specializing in multi-tenant JPA applications
    with {{tech_stack}}. Your task is to analyze a database schema and create a
    detailed implementation plan for code generation.

# =============================================================================
# CONTEXT SECTION
# Variables: entity, table, bounded_context, scope, artifacts, schema_file
# =============================================================================
context:
  header: |
    **Entity:** {{entity}}
    **Table:** {{table}}
    **Bounded Context:** {{bounded_context}}
    **Scope:** {{scope}}
    **Artifacts to Generate:** {{artifacts}}

  schema_reference: |
    ### Schema

    Read the schema DDL at `{{schema_file}}` to understand the table structure,
    columns, constraints, and relationships.

# =============================================================================
# INPUT VALIDATION (V2)
# Guidance on what to do if required inputs are missing or invalid
# =============================================================================
input_validation:
  header: "### Input Validation"
  content: |
    Before proceeding, verify:
    1. The schema file at `{{schema_file}}` exists and is readable
    2. The file contains DDL for the `{{table}}` table

    **If validation fails:** STOP immediately and report:
    ```
    VALIDATION FAILED: [reason]
    - Expected: [what was expected]
    - Found: [what was actually found or "file not found"]
    ```

    Do not attempt to guess or assume schema structure if the file is missing or malformed.

# =============================================================================
# CONVENTIONS SECTION
# These tables are always included - values come from conventions.json
# =============================================================================
conventions:
  naming:
    header: "**Naming:**"
    table:
      - artifact: Entity class
        pattern: "{{entity_class}}"
      - artifact: Repository
        pattern: "{{repository_class}}"
      - artifact: Service
        pattern: "{{service_class}}"
      - artifact: Controller
        pattern: "{{controller_class}}"
      - artifact: Request DTO
        pattern: "{{dto_request_class}}"
      - artifact: Response DTO
        pattern: "{{dto_response_class}}"
      - artifact: Mapper
        pattern: "{{mapper_class}}"

  packages:
    header: "**Packages:**"
    table:
      - artifact: Entity
        package: "{{entity_package}}"
      - artifact: Repository
        package: "{{repository_package}}"
      - artifact: Service
        package: "{{service_package}}"
      - artifact: Controller
        package: "{{controller_package}}"
      - artifact: DTO
        package: "{{dto_package}}"
      - artifact: Mapper
        package: "{{mapper_package}}"

  technical:
    header: "**Technical:**"
    table:
      - setting: Primary key type
        value: "{{id_type}}"
      - setting: Public ID type
        value: "{{public_id_type}}"
      - setting: Timestamp type
        value: "{{timestamp_type}}"
      - setting: Tenant ID type
        value: "{{tenant_id_type}}"

# =============================================================================
# TASK PHASES
# Selected based on artifacts in scope
# =============================================================================
task:
  intro: |
    Analyze the schema for the `{{table}}` table and create a comprehensive
    implementation plan for the `{{entity}}` entity.

  # Common phases included for all scopes
  common:
    - phase: Schema Analysis
      steps:
        - List all columns with their SQL types
        - Identify nullable vs non-nullable columns
        - Note any default values or constraints
        - Identify primary key column(s) and generation strategy
        - Identify foreign key columns and their targets

    - phase: Multi-Tenancy Classification
      description: |
        Classify the entity into one of these categories:

        | Category | Schema | Has {{tenant_column}} | Example |
        |----------|--------|---------------|---------|
        | Global Reference | `{{global_schema_example}}.*` | No | tiers, categories |
        | Tenant-Scoped | `{{tenant_schema_example}}.*` | Yes | users, projects |
        | Top-Level Tenant | `{{tenant_table}}` | No (IS tenant) | {{tenant_entity_lower}} |

  # Artifact-specific phases
  artifacts:
    entity:
      phase: Entity Design Decisions
      # First step is conditional based on base_entity_class - handled by profile
      base_entity_step_with_class: "Determine if entity should extend `{{base_entity_class}}` (provides: {{base_entity_fields}}). Extend if: {{base_entity_criteria}}"
      base_entity_step_without_class: "Design entity fields from scratch (no project base entity defined)"
      steps:
        - Map SQL types to Java types for each column
        - Identify @Column annotation requirements (name, nullable, length)
        - Plan relationship mappings (ManyToOne, OneToMany) with fetch/cascade strategies
        - Identify validation annotations (@NotNull, @Size, etc.)
        - Note any special handling (JSONB, enums, converters)

    repository:
      phase: Repository Design Decisions
      steps:
        - Identify standard CRUD methods needed
        - Plan tenant-scoped query methods (findByClientIdAnd...)
        - Identify custom @Query methods for complex lookups
        - Consider pagination requirements
        - Note any projections or DTOs for read optimization

    service:
      phase: Service Design Decisions
      steps:
        - Identify business operations (create, update, delete, custom operations)
        - Determine transaction boundaries (@Transactional scope)
        - List repository dependencies
        - Identify cross-service dependencies
        - Plan validation logic beyond entity constraints
        - Consider event publishing requirements

    controller:
      phase: Controller Design Decisions
      steps:
        - Design REST endpoints (HTTP method, path, description)
        - Map operations to HTTP verbs (GET, POST, PUT, PATCH, DELETE)
        - Plan request/response DTO usage per endpoint
        - Identify path variables and query parameters
        - Determine security requirements (@PreAuthorize, roles)
        - Plan error response handling

    dto:
      phase: DTO Design Decisions
      steps:
        - Identify fields for request DTO (create/update input)
        - Identify fields for response DTO (API output)
        - Plan validation annotations on request DTO
        - Determine which entity fields to expose vs hide
        - Consider nested DTOs for relationships
        - Plan any view-specific response variants

    mapper:
      phase: Mapper Design Decisions
      steps:
        - Plan entity → response DTO mapping
        - Plan request DTO → entity mapping (create)
        - Plan request DTO → entity mapping (update/patch)
        - Identify fields requiring special handling
        - Plan nested object mapping strategy
        - Consider collection mapping approach

# =============================================================================
# CONSTRAINTS
# =============================================================================
constraints:
  critical:
    header: "### CRITICAL Requirements"
    items:
      - "**DO NOT generate code** - This is planning phase only"
      - "**DO NOT assume fields** - Derive everything from schema DDL"
      - "**Cite rule IDs** for any standards-based decisions (e.g., \"Per JPA-ENT-001...\")"
      - "**Flag uncertainties** - Mark assumptions with [ASSUMPTION] tag"

  technical:
    header: "### Technical Constraints"
    content: "{{technical_constraints}}"

# =============================================================================
# EXPECTED OUTPUT
# Structure of the plan.md file the AI should create
# =============================================================================
expected_output:
  intro: "Create a file named `plan.md` with the following structure:"

  # Common sections always included
  common:
    - section: Schema Analysis
      items:
        - "Table: {{table}}"
        - "Columns: [table of columns with types]"
        - "Relationships: [identified FKs and their targets]"

    - section: Multi-Tenancy
      items:
        - "Classification: [Global/Tenant-Scoped/Top-Level]"
        - "Scoping Strategy: [how tenant isolation is enforced]"

  # Artifact-specific design sections
  artifacts:
    entity:
      section: Entity Design
      # First item is conditional based on base_entity_class - handled by profile
      extends_item_with_class: "Extends: {{base_entity_class}} | None"
      extends_item_without_class: "Fields: [all fields - no base entity]"
      items:
        - "Fields: [table mapping column -> field -> type]"
        - "Relationships: [ManyToOne/OneToMany with fetch/cascade]"
        - "Validations: [@NotNull, @Size, etc.]"

    repository:
      section: Repository Design
      items:
        - "Standard Methods: [list with signatures]"
        - "Custom Queries: [any @Query methods needed]"

    service:
      section: Service Design
      items:
        - "Public Methods: [list with signatures]"
        - "Transaction Boundaries: [where @Transactional applies]"
        - "Dependencies: [repositories or other services needed]"

    controller:
      section: Controller Design
      items:
        - "Endpoints: [HTTP method, path, description]"
        - "Request/Response: [DTO types for each endpoint]"
        - "Security: [authorization requirements]"

    dto:
      section: DTO Design
      items:
        - "Request DTO: [fields for create/update operations]"
        - "Response DTO: [fields to expose in responses]"
        - "Validation: [field constraints]"

    mapper:
      section: Mapper Design
      items:
        - "Entity → Response: [mapping strategy]"
        - "Request → Entity: [mapping strategy]"
        - "Special Handling: [nested objects, collections]"

  # File list - entries selected based on artifacts
  file_list:
    header: "Files to generate (use the package and naming conventions above):"
    entries:
      entity:
        file: Entity
        package: "{{entity_package}}"
        class: "{{entity_class}}"
      repository:
        file: Repository
        package: "{{repository_package}}"
        class: "{{repository_class}}"
      service:
        file: Service
        package: "{{service_package}}"
        class: "{{service_class}}"
      controller:
        file: Controller
        package: "{{controller_package}}"
        class: "{{controller_class}}"
      dto_request:
        artifact: dto
        file: Request DTO
        package: "{{dto_package}}"
        class: "{{dto_request_class}}"
      dto_response:
        artifact: dto
        file: Response DTO
        package: "{{dto_package}}"
        class: "{{dto_response_class}}"
      mapper:
        file: Mapper
        package: "{{mapper_package}}"
        class: "{{mapper_class}}"

  # Closing sections always included
  closing:
    - section: Open Questions
      guidance: |
        Use this section for decisions that:
        - Have multiple valid approaches with different trade-offs
        - Depend on business context not available in the schema
        - Require clarification of ambiguous requirements
        - Could significantly impact downstream artifacts

        Do NOT include questions that can be answered from the schema or standards.
        Each question should include: context, options considered, and recommendation if you have one.
      items:
        - "[Any uncertainties or decisions needing human input]"

    - section: Standards Compliance
      items:
        - "[List applicable rules and how they'll be satisfied]"

# =============================================================================
# PRE-OUTPUT CHECKLIST (V3)
# Self-verification before declaring the plan complete
# =============================================================================
pre_output_checklist:
  header: "### Pre-Output Checklist"
  intro: "Before stopping, verify your plan includes:"
  # Third item is conditional based on base_entity_class - handled by profile
  base_entity_check_with_class: "[ ] {{base_entity_class}} decision is documented with rationale"
  base_entity_check_without_class: "[ ] Entity field design is complete (no base entity to extend)"
  items:
    - "[ ] All columns from schema DDL are accounted for (mapped or explicitly excluded with reason)"
    - "[ ] Multi-tenancy classification is justified with evidence from schema"
    - "[ ] All relationships have explicit fetch strategy (LAZY) and cascade settings"
    - "[ ] Each design decision cites a rule ID from standards or marks [ASSUMPTION]"
    - "[ ] File list matches the artifacts for this scope"

# =============================================================================
# INSTRUCTIONS
# =============================================================================
instructions:
  items:
    - "Read the schema file at `{{schema_file}}`"
    - "Verify input files exist (see Input Validation above)"
    - "Analyze thoroughly before writing"
    - "Create `plan.md` with your implementation plan"
    - "Run through the Pre-Output Checklist"
    - "**STOP and wait for approval** - Do not proceed to code generation"
